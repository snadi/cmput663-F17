* Analyze merge commits in two or more repositories. How many of these merge commits resulted in conflicts that needed to be solved before merging? Were these syntactic conflicts? Were they semantic conflicts? How were these conflicts resolved? Can you come up with a catalog of resolution strategies? Can you come up with predictive features of merge conflicts? Some relevant papers you may wish to explore: [1](http://dl.acm.org/citation.cfm?id=2819164), [2](http://ieeexplore.ieee.org/abstract/document/7321191/), [3](http://dl.acm.org/citation.cfm?id=2025139), A related paper coming up in [OOPSLA '17](http://2017.splashcon.org/track/splash-2017-OOPSLA), and [4](https://www.infosun.fim.uni-passau.de/publications/docs/LSA+17ase.pdf).
* Can we collect API usage fixed by looking at code evolution? Look at historic commits and identify commit messages that mention changing something to make it faster, more secure, more readable etc.
Record the pair of before and after code snippets and record the aspect that the second snippet is better in. Can you then aggregate this data to come up with meaningful patterns or to use this information in a recommender system down the line? Some relevant papers you may wish to explore: [1](http://maveric0.uwaterloo.ca/~migod/papers/2009/icpc09-abram.pdf) and [2](https://www.researchgate.net/profile/Christian_Bird/publication/221560341_The_Missing_Links_Bugs_and_Bug-fix_Commits/links/004635142b205c9132000000.pdf).
* Come up with heuristics/techniques for reverse-engineering configuration constraints for Java projects. You can take a look at TypeChef's Java analysis framework and see what available analyses can you use. [This paper](http://dl.acm.org/citation.cfm?id=2643001) and [this paper](http://dl.acm.org/citation.cfm?id=2568283) are relevant.
* By mining commit messages, developer discussions etc., identify misconfigurations that lead to security errors. A first step here would be to look at the literature and see if such errors have been reported and then using the characteristics of these errors as queries in the mining process.  Related papers include: [1](http://dl.acm.org/citation.cfm?id=1882308), [2](https://suif.stanford.edu/papers/fse05.pdf), [3](http://ieeexplore.ieee.org/abstract/document/5463340/), and [4](http://dl.acm.org/citation.cfm?id=2043572). You might also make use of the [CVE](https://cve.mitre.org/) dataset to see if any of the reported vulnerabilities are due to misconfigurations.
* Study a project on GitHub that has many feature branches and/or forks and investigate how are features introduced. For example, how do these branches/forks get integrated back to main? What kind of system changes are needed? Examples of such systems include JabRef and Checkstyle. Both these projects heavily use pull requests for new features and bug fixes. Related papers include [1](http://ieeexplore.ieee.org/abstract/document/7332461/) and [2](https://hal.inria.fr/hal-01519079/document).
* Study the commit history of the Linux kernel and see if co-changed features can be used to predict configuration constraints. In other words, if any updates to the dependencies of CONFIG_X always happen with updates to the dependencies of CONFIG_Y or if changes to the code surrounded by #ifdef CONFIG_X always happen with changes to the code surrounded by #ifdef CONFIG_Y. How many of the existing documented constraints in Kconfig can you recover? What is your false positive or accuracy/precision rate? You may also want to make use of the commit message text itself to look for keywords. The following papers are related: [1](http://dl.acm.org/citation.cfm?id=2568283), [2](http://dl.acm.org/citation.cfm?id=2487112), [3](http://www.st.uni-trier.de/~diehl/pubs/icse04.pdf), [4](http://dl.acm.org/citation.cfm?id=2491628) and [5](http://dl.acm.org/citation.cfm?id=1138001).
* Take a look at the [2018 Mining Software Repositories conference mining challenge](http://conf.researchr.org/home/msr-2018) and see if you can come up with interesting research questions (and answers!) about evolution of source code and/or how developers interact with their IDE.
* You may propose your own topic as well, as long as it aligns with the general topics and types of studies discussed in class. 